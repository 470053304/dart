\section{Forward Simulation}
In this section, we will build and simulate a simple chain of rigid
bodies connected by ball joints. This example demonstrates how an
articulated rigid body system is represented using DART data
structures and how a simulation step is formulated using different
numerical integration methods.

Because this is the first example, we will examine the source code in
more details. To create and visualize a basic simulation app, we
integrate DART into Glut framework. All the examples in this tutorial
use Glut and OpenGL libraries to handle user interface and
rendering. However, DART does not assume a particular UI or rendering
package. 


\subsection{Simulation step}
Let us begin with the main function. The main function does two
things: loading a skeleton file and creating a window for UI and
rendering. 

A skeleton comprises a set of body nodes connected by
joints. We can directly load a skeleton from a file or manually build a new
skeleton in the code. DART currently supports two formats of skeleton
file: .vsk and .skel. In this example, we load in a skeleton with 10
rigid links connected by ball joints. 

Once \textbf{glutMainLoop} is invoked in the main function, Glut
callback functions will start handling display updates, keyboard
inputs, etc. The simulation code is called from the callback function
\textbf{displayTimer()} in MyWindow.cpp.

\ttfamily
\begin{lstlisting}[label=displayTimer,caption=displayTimer]
void MyWindow::displayTimer(int _val)
{
    int numIter = mDisplayTimeout / (1000 * mTimeStep);
    for (int i = 0; i < numIter; i++) {
      mIntegrator.integrate(this, mTimeStep);
      mFrame++;
    }
    glutPostRedisplay();
    if (mRunning)	
        glutTimerFunc(mDisplayTimeout, refreshTimer, _val);
}
\end{lstlisting}
\rmfamily
\textbf{displayTimer()} is called every \textbf{mDsiplayTimeout}
millisecond. Because \textbf{mDsiplayTimeout} is typically larger than
the simulation time step (\textbf{mTimeStep}), we need to run a few
iterations of simulation steps each time \textbf{displayTimer()} is
called. The number of iterations is computed as
\textbf{numIter}. \textbf{mIntegrator} is a data member of
\textbf{MyWindows} and can be declared as an explicit Euler integrator
or a RK4 integrator in MyWindows.h. Since we do not have
internal or external forces applied to the skeleton in this example,
calling \textbf{integrate()} is the only procedure required to
simulate.

\subsection{Integration}
\textbf{Integrator Class} has three virtual member functions,
\textbf{getState()}, \textbf{setState()}, and \textbf{evalDeriv},
which need to be implemented in the app. \textbf{getState()} and
\textbf{setState()} retrieve and assign the value of current state,
which includes the current degrees of freedom (DOFs) and the velocity
of DOFs. The most involved function is \textbf{evalDeriv}, which
computes the derivative of the current state via equations of motion.

\ttfamily
\begin{lstlisting}[label=evalDeriv,caption=evalDeriv]
VectorXd MyWindow::evalDeriv() {
    mModel->setPose(mDofs, false, false);
    mModel->computeDynamics(mGravity, mDofVels, true);
    VectorXd deriv(mDofs.size() + mDofVels.size());
    VectorXd qddot = mModel->getInvMassMatrix() 
        * (-mModel->getCombinedVector());
    mModel->clampRotation(mDofs, mDofVels);
    deriv.head(mDofs.size()) = mDofVels + mTimeStep * qddot;
    deriv.tail(mDofVels.size()) = qddot;
    return deriv;
}
\end{lstlisting}
\rmfamily
In \textbf{evalDeriv}, we first call \textbf{setPose()} to update the
DOF values in the skeleton. \textbf{setPose()} takes in two boolean
flags. The first flag indicates whether to update all the
transformation matrices and the second flag indicates whether to
update first derivatives of the transformation matrices. Here we set
both of them to be false because the next function, 
\textbf{computeDynamics()}, will take care of the update of
transformation matrices and we do not need the information about first
derivatives in this app. As a rule of thumb, setting both flags to
true is the safest option, as it will provide the most complete
information at the cost of computation time.

\textbf{computeDynamics()} updates the mass matrix (and its
inversion), Coriolis and centrifugal force, generalized gravitational force,
and generalized external force based on the current DOFs and DOF
velocity. This is the most important function in DART, and obviously,
the most computational costly one. To speed up the computation time,
DART provides an alternative way to compute Coriolis, centrifugal, and
gravitational force using recursive inverse dynamics (See
\cite{dynamics-tutorial} for details). If the flag in
\textbf{computeDynamics()} is true, DART will utilize recursive
inverse dynamics formula to speed up the computation.

Once the terms in equations of motion are updated, the acceleration of
DOF (\textbf{qddot}) can be readily computed. Note that
\textbf{getCombinedVector()} returns the sum of Coriolis, centrifugal,
and gravitational force, instead of each individual force.

\textbf{clampRotation() } is particularly important when a joint is
represented as an exponential map rotation. The system will become
unstable if the exponential map rotation is outside the range of
2PI. Once the rotation magnitude is changed, the velocity needs to
change accordingly to represent the same angular velocity.
