\section{Contacts}
This section introduces the collision detection and handling in DART. We
will simulate three boxes and the ground and visualize their motion
due to collisions. We follow the same Glut framework described in the
previous section, but in this example we allow the user to apply
forces to interact one of the boxes. We also add playback
functionality so the user can replay the simulation result.

\subsection{Contact dynamics}
Collision detection and handling are implemented in
\textbf{ContactDynamics Class}. To include collision functionality in
the application, the user needs to create an instance of
\textbf{ContactDynamics}. The constructor of \textbf{ContactDynamics
  Class} requires the user to pass in a list of skeletons potentially
participating collision, the simulation time step, friction
coefficient (\_mu), and the number of friction cone basis vectors
(\_d). The default values for \_mu and \_d are 1.0 and 4. In general, a
smaller \_mu indicates a more slippery the colliding surface, and a
larger \_d results in more accurate the sliding contact. Please see
\cite{LCP-tutorial} for detailed implementation of LCP contact
modeling.

Applying collision detection and handling is very straightforward in
DART once \textbf{ContactDynamics} is instantiated. The user can call
the member function, \textbf{applyContactForces()}, every time
collision and contact forces need to be updated. The resulting contact
forces are represented in two different
ways. \textbf{getConstraintForce()} returns the contact forces in
generalized coordinates of a desired skeleton. Alternatively, the user
can retrieve the contact forces in the Cartesian space by accessing
the data structure of each contact point via
\textbf{getCollisionChecker()}. We will see examples of both cases in
the next subsection.

\subsection{Simulation}

\subsubsection{Initialization}
\textbf{initDyn()} for this example is very similar to the one
described in Section \ref{}: we initialize the simulation state variables, \textbf{mDofs} and
\textbf{mDofVels}, and then initialize the dynamic variables and the
pose of the skeleton. The differences in this example are the following.
\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::initDyn()
{
  .....
  mSkels[0]->setImmobileState(true);
  mCollisionHandle = new dynamics::ContactDynamics(mSkels, 
      mTimeStep);
}
\end{lstlisting}
\rmfamily First, we set the ``ground'' skeleton to be immobile. If a
skeleton is immobile, it is not included in the dynamic simulation,
namely, it cannot be moved by forces. However, it still participates
in collision detection and will induce contact forces to other
skeletons. Second, we create an instance of \textbf{ContactDynamics
  Class}, \textbf{mCollisionHandle}, to handle collisions between all the
skeletons in the scene, including a ground and three boxes.

\subsubsection{Simulation step}
Again, simulation code is invoked from the callback function
\textbf{displayTimer()}. In this example, we add a new feature of
playback, which bakes and replays the simulation results.

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::displayTimer(int _val)
{
  int numIter = mDisplayTimeout / (mTimeStep * 1000);
  if (mPlay) {
    mPlayFrame += 16;
    if (mPlayFrame >= mBakedStates.size())
      mPlayFrame = 0;
 }else if (mSim) {
    for (int i = 0; i < numIter; i++) {
      static_cast<BodyNodeDynamics*>(mSkels[1]->getNode(0))
          ->addExtForce(Vector3d(0.0, 0.0, 0.0), mForce);
      mIntegrator.integrate(this, mTimeStep);
      bake();
      mSimFrame++;
    }
    mForce.setZero();
  }
  glutPostRedisplay();
  glutTimerFunc(mDisplayTimeout, refreshTimer, _val);
}
\end{lstlisting}
\rmfamily When the flag \textbf{mPlay} is true, playback mode is
active and the frame index \textbf{mPlayFrame} is incrementing based
on the desired playback speed ($16$ is arbitrarily chosen). If
\textbf{mSim} is true, DART enters the simulation mode and runs
\textbf{numIter} steps of simulation as described in Section
\ref{}. The difference in this example is that the user can push the
largest box on the ground and DART will take into account this
external force in the simulation. \textbf{addExtForce()} is a member
function of \textbf{BodyNodeDynamics Class}. It takes input arguments
as the coordinates of the point of application in the body frame, as
well as the force vector in the world frame. \textbf{addExtForce()}
also provides the options to express the point of application in the
world frame or the force vector in the body frame.

\ttfamily
\begin{lstlisting}[caption=BodyNodeDynamics.h]
void addExtForce( const Eigen::Vector3d& _offset, 
                             const Eigen::Vector3d& _force, 
                             bool _isOffsetLocal=true, 
                             bool _isForceLocal=false );
\end{lstlisting}
\rmfamily

After each integration step, we call \textbf{bake()} to store the new
states of the skeletons and the collision results. The information of
collision is stored in the data structure \textbf{ContactPoint}.
\ttfamily
\begin{lstlisting}[caption=CollisionSkeleton.h]
struct ContactPoint {
  Eigen::Vector3d point;
  Eigen::Vector3d normal;
  Eigen::Vector3d force;
  .....
}
\end{lstlisting}
\rmfamily

The developer can access the position, normal, and force of any
contact point via the member data, \textbf{mCollisionChecker} in
\textbf{ContactDynamics Class}).  

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::bake()
{
  int nContact = mCollisionHandle->getCollisionChecker()->getNumContact();
  VectorXd state(mIndices.back() + 6 * nContact);
  for (unsigned int i = 0; i < mSkels.size(); i++)
  state.segment(mIndices[i], mDofs[i].size()) = mDofs[i];
  for (int i = 0; i < nContact; i++) {
    int begin = mIndices.back() + i * 6;
    state.segment(begin, 3) = mCollisionHandle->getCollisionChecker()->getContact(i).point;
    state.segment(begin + 3, 3) = mCollisionHandle->getCollisionChecker()->getContact(i).force;
  }
  mBakedStates.push_back(state);
}
\end{lstlisting}
\rmfamily

\subsubsection{Integration}

\ttfamily
\begin{lstlisting}[label=evalDeriv,caption=evalDeriv]
VectorXd MyWindow::evalDeriv() {
  // compute dynamic equations
  for (unsigned int i = 0; i < mSkels.size(); i++) {
    if (mSkels[i]->getImmobileState()) {
      // need to update node transformation for collision
      mSkels[i]->setPose(mDofs[i], true, false);
    } else {
      // need to update first derivatives for collision
      mSkels[i]->setPose(mDofs[i], false, true);
      mSkels[i]->computeDynamics(mGravity, mDofVels[i], true);
    }
  }
  // compute contact forces
  mCollisionHandle->applyContactForces();

  // compute derivatives for integration
  VectorXd deriv = VectorXd::Zero(mIndices.back() * 2);    
  for (unsigned int i = 0; i < mSkels.size(); i++) {
    // skip immobile objects in forward simulation
    if (mSkels[i]->getImmobileState())
      continue;
    int start = mIndices[i] * 2;
    int size = mDofs[i].size();
    VectorXd qddot = mSkels[i]->getInvMassMatrix() 
        * (-mSkels[i]->getCombinedVector() 
        + mSkels[i]->getExternalForces() 
        + mCollisionHandle->getConstraintForce(i));
    mSkels[i]->clampRotation(mDofs[i], mDofVels[i]);
    deriv.segment(start, size) = mDofVels[i] + (qddot * mTimeStep);
    deriv.segment(start + size, size) = qddot;
  }
  return deriv;
}
\end{lstlisting}
\rmfamily



